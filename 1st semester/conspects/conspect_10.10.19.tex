\documentclass[a4paper,12pt]{article}
\usepackage{cmap}
\usepackage {listings}
\usepackage {misccorr}
\usepackage{graphicx}
\setlength{\parindent}{5ex}	
\usepackage{amssymb}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\author{Зарина}
\title{Алгоритмы}
\date{10 окрября 2019}
\begin{document}
\section {Принцип двух указателей}
- актуален, если речь идет о задачах, которые решаются методом полного перебора. \\ \\
\textbf{Задача 1. Вариант 1.} 

Дано константное значение D и последовательность {\bfseries  $a_{1}, a_{2}, … , a_{n}$}. Существует ли подпоследовательность, сумма элементов которой будет больше D? Напишем функцию полного перебора, проверяющую наличие такой подпоследовательности:

\lstset {language = C++, frame = single}
\begin{lstlisting}
bool exist1(int arr[], int D)
{
    for (int i = 0; i < n; i++)
    {
        s = 0;
        for (int j = i; j < n; j++)
        {
            s += arr[j];
            if (s > D)
            {
                 return 1;
            }
        }
    }
	return 0;
}
\end{lstlisting}

\textbf{Какова сложность такого алгоритма?} Каждый раз осуществляется проверка, сначала {\bfseries n} раз, потом {\bfseries n-1}, и так далее, пока не дойдем до {\bfseries 1}. => Общее количество шагов –  сумма n членов арифметической прогрессии: $O(1 + 2 + … + n) = O(\frac {n \cdot (1+n)} {2}) = O(n^2)$.\\ \\
\textbf{Задача 1. Вариант 2.}\\
Представим последовательность, где какие-то элементы положительные, а какие-то – отрицательные. Имеет ли смысл учитывать последовательность, сумма элементов которой отрицательна? Нет.\\
Реализуем оптимизированный алгоритм:

\begin{lstlisting}
bool exist1(int arr[], int D)
{
    for (int i = 0; i < n; i++)
    {
        s = 0;
        for (int j = i; j < n; j++)
        {
            s += arr[j];
            if (s > D)
            {
                 return 1;
            }
            if (s < 0)
            {
                 i = j;
                 break;
            }
        }
    }
	return 0;
}
\end{lstlisting}

Теперь роль в вычислении асимптитики играет только вложенный цикл, в худшем случае количество перебираемых вариантов будет равно n: $O(n)$.

\section {Разделяй и властвуй}
- разбиение основной задачи на несколько более маленьких, пока эти подзадачи не станут элементарными.\\ \\
\textbf{Бинарный (двоичный) поиск:} 

Дано: некоторый элемент x и последовательность $a_{1}, a_{2},\ldots, a_{n}$, в которой каждый следующий элемент (например) больше предыдущего или равен ему.

Определить: найдется ли в данной последовательности такой элемент, который равен x.

Решение: Возьмем произвольный элемент $a_{k}$ такой, что $1 \le k \le n$, и сравним его с x. Есть всего три варианта:

\begin{enumerate}
  \item $x < a_{k}$. Значит, ищем в левой части: $\{\,a_{1},\ldots,a_{k-1}\,\}$
  \item $x = a_{k}$. Элемент найден
  \item $x > a_{k}$. Значит, ищем в правой части: $\{\,a_{k+1},\ldots,a_{n}\,\}$
\end{enumerate}

За каждое сравнение мы сокращаем количество рассматриваемых элементов вдвое: $k = [\frac {n}{2}]$.

\textbf{Асимптотическая сложность:} $O(\log_{2}n)$, т.к. рассматриваем сначала $O(n)$, затем $O(\frac{n}{2})$, $O(\frac{n}{4})$, \ldots , $O(\frac{n}{2^{m}})$.=> Получается следующее: $\frac{n}{2^{m}}=1$; $n=2^{m}$; $m=\log_{2}n$.

\section {Сортировка слиянием - merge sort}

- деление исходного массива на несколько массивов меньшего размера (Чтобы потом их быстро отсортировать).\\ Рассмотрим принцип работы алгоритма на двух массивах. Пусть у нас есть массив отсортированный а длины n и отсортированный массив b длины m, из них мы хотим получить массив c длины n+m. Реализуем алгоритм слияния:
\lstset {language = C++, frame = single}
\begin{lstlisting}
i = 0;
j = 0;
for (int k = 0; k < n + m; k++)
{
    c[k] = min(a[i],b[j]); 
    if (a[i] <= b[j]) 
    {
        i++;
    }
    else
    {
        j++;
    }
}
\end{lstlisting}

$c[k] = min(a[i],b[j]); $ - меньший из элементов записываем в новый массив;

$i++$ - увеличиваем счетчик у массива, чей элемент записали, затем делаем новое сравнение;\\ Замечание: когда элементы в каком-то из массивов закончатся, то впишем в c все элементы из оставшегося непустого массива.

Данный метод можно применить для сортировки одного исходного массива: разобьем его на две части, чтобы потом воспользоваться алгоритмом слияния. \\Но эти два подмассива должны быть отсортированы. Тогда каждый из этих подмассивов нужно разбить еще на две части. И так до тех пор, пока массивы не будут состоять из одного или двух элементов.\\ \\
\textbf{Асимптотическая сложность:} $O(n \cdot \log_{2}n)$, т.к. на первом шаге у нас два массива длины $\frac{n}{2}$, то есть сложность $O(n)$; на втором шаге у нас уже четыре массива, длина каждого из которых $\frac{n}{4}$, то есть сложность $4 \cdot O(\frac{n}{4}) = O(n)$ и так далее. => $\log_{2}n$ шагов, сложность каждого из которых $O(n)$ => $O(n \cdot \log_{2}n)$.
\\

\textbf{Timsort:}\\
Алгоритм сортировки слиянием неэффективен при массивах небольшой длины, так что обычно используют {\slshape timsort} -это сортировка-гибрид из сортировки слиянием и сортировки вставками. Основной способ – сортировка слиянием, но с некоторого момента будет использоваться сортировка вставками, что эффективно для массивов небольшой длины.

\end{document}