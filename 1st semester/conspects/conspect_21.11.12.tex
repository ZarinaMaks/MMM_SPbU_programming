\documentclass[a4paper,12pt]{article}
\usepackage{cmap}
\usepackage {listings}
\usepackage{verbatim}
\usepackage {misccorr}
\usepackage{graphicx}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{amsfonts}
\usepackage[linesnumbered,boxed]{algorithm2e}
\usepackage{longtable}
\usepackage{color,colortbl}
\definecolor{Red}{RGB}{230,170,200}
\author{Зарина}
\title{Вероятностыне алгоритмы и хэширование}
\date{21 ноября 2019}
\usepackage{indentfirst}
\begin{document}
\section{Вероятностные алгоритмы}
Рассмотрим следующие типы алгоритмов:\\

\textbf{1) Статистические алгоритмы} -- алгоритмы, работающие со случайными данными: Фильтр Калмана.\\

\textbf{2) Стохастические алгоритмы}\\

\textbf{3) Обработка случайных событий}\\

\textbf{4) Вероятностные алгоритмы} -- ряд тестов, дающих правильный ответ с некоторой вероятностью.\\
Это алгоритм, предусматривающий обращение на определённых этапах своей работы к генератору случайных чисел с целью получения экономии во времени работы за счёт замены абсолютной достоверности результата достоверностью с некоторой вероятностью.\\
Вероятностные алгоритмы предназначены для решения задач (например, \textbf{проверка на простоту}), точное решение которых является невозможным или менее рациональным (слишком дорогим, требующим слишком много времени и т.п.). Посредством вероятностных алгоритмов можно вычислить в точности те же функции, что и посредством обычных, детерминированных алгоритмов.\\
\section{Обработка случайных событий. Код Хэмминга}
Код Хэмминга — вероятно, наиболее известный из первых самоконтролирующихся и самокорректирующихся кодов. Построен применительно к двоичной системе счисления. Позволяет исправлять одиночную ошибку (ошибка в одном бите) и находить двойную.\\

Другими словами, это алгоритм, который позволяет закодировать какое-либо информационное сообщение определённым образом и после передачи (например по сети) определить появилась ли какая-то ошибка в этом сообщении (к примеру из-за помех) и, при возможности, восстановить это сообщение. \\

\textbf{Алгоритм кодирования:}\\

Предположим, что нужно сгенерировать код Хэмминга для некоторого информационного кодового слова. В качестве примера возьмём 8-битовое кодовое слово , хотя алгоритм пригоден для кодовых слов любой длины. В приведённой ниже таблице в первой строке даны номера позиций в кодовом слове, во второй — значения битов.\\
\\
\\
\\
\\
\begin{table}[!h]
\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|c|}
\hline
1&2&3&4&5&6&7&8\\
\hline
1&1&0&0&1&0&1&1\\
\hline
\end{tabular}
\end{center}
\end{table}\\

Вставим в информационное слово контрольные биты таким образом, чтобы номера их позиций представляли собой целые степени двойки: 1, 2, 4, 8… Получим 12-разрядное слово с 8 информационными и 4 контрольными битами. Первоначально контрольные биты устанавливаем равными нулю. На рисунке контрольные биты выделены розовым цветом.\\
\begin{table}[!h]
\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|}
\hline
1&2&3&4&5&6&7&8&9&10&11&12\\
\hline
\cellcolor{Red}0&\cellcolor{Red}0&1&\cellcolor{Red}0&1&0&0&\cellcolor{Red}0&1&0&1&1\\
\hline
\end{tabular}
\end{center}
\end{table}\\
В общем случае количество контрольных бит в кодовом слове равно двоичному логарифму числа, на единицу большего, чем количество бит кодового слова (включая контрольные биты); логарифм округляется в большую сторону. Например, информационное слово длиной 1 бит требует двух контрольных разрядов, 2-, 3- или 4-битовое информационное слово — трёх, 5…11-битовое — четырёх, 12…26-битовое — пяти и т. д. \\


\noindentДобавим к таблице 4 строки (по количеству контрольных битов), в которые поместим матрицу преобразования. Каждая строка будет соответствовать одному контрольному биту (нулевой контрольный бит — верхняя строка, третий — нижняя), каждый столбец — одному биту кодируемого слова. В каждом столбце матрицы преобразования поместим двоичный номер этого столбца, причём порядок следования битов будет обратный — младший бит расположим в верхней строке, старший — в нижней. Например, в третьем столбце матрицы будут стоять числа 11000, что соответствует двоичной записи числа три: 00011.\\
\begin{table}[!h]
\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}
\hline
1&2&3&4&5&6&7&8&9&10&11&12&&\\
\hline
\cellcolor{Red}0&\cellcolor{Red}0&1&\cellcolor{Red}0&1&0&0&\cellcolor{Red}0&1&0&1&1&&\\
\hline
1&0&1&0&1&0&1&0&1&0&1&0&$s_0$&\\
\hline
0&1&1&0&0&1&1&0&0&1&1&0&$s_1$&\\
\hline
0&0&0&1&1&1&1&0&0&0&0&1&$s_2$&\\
\hline
0&0&0&0&0&0&0&1&1&1&1&1&$s_3$&\\
\hline
\end{tabular}
\end{center}
\end{table}\\
\\
В правой части таблицы мы оставили пустым один столбец, в который поместим результаты вычислений контрольных битов. Вычисление контрольных битов производим следующим образом. Берём одну из строк матрицы преобразования (например, $s_0$) и находим её скалярное произведение с кодовым словом, то есть перемножаем соответствующие биты обеих строк и находим сумму произведений. Если сумма получилась больше единицы, находим остаток от его деления на 2. Иными словами, мы подсчитываем сколько раз в кодовом слове и соответствующей строке матрицы в одинаковых позициях стоят единицы и берём это число по модулю 2\\
\begin{table}[!h]
\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}
\hline
1&2&3&4&5&6&7&8&9&10&11&12&&\\
\hline
\cellcolor{Red}0&\cellcolor{Red}0&1&\cellcolor{Red}0&1&0&0&\cellcolor{Red}0&1&0&1&1&&\\
\hline
1&0&1&0&1&0&1&0&1&0&1&0&$s_0$&0\\
\hline
0&1&1&0&0&1&1&0&0&1&1&0&$s_1$&0\\
\hline
0&0&0&1&1&1&1&0&0&0&0&1&$s_2$&0\\
\hline
0&0&0&0&0&0&0&1&1&1&1&1&$s_3$&1\\
\hline
\end{tabular}
\end{center}
\end{table}\\
Полученные контрольные биты вставляем в кодовое слово вместо стоявших там ранее нулей. По аналогии находим проверочные биты в остальных строках. Кодирование по Хэммингу завершено. Полученное кодовое слово — 001010011011.\\

\textbf{Алгоритм декодирования:}\\
Алгоритм декодирования по Хэммингу абсолютно идентичен алгоритму кодирования. Допустим что, 3 бит передался неправильный, тогда матрица примет следующий вид:\\
\begin{table}[!h]
\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}
\hline
1&2&3&4&5&6&7&8&9&10&11&12&&\\
\hline
\cellcolor{Red}0&\cellcolor{Red}0&0&\cellcolor{Red}0&1&0&0&\cellcolor{Red}0&1&0&1&1&&\\
\hline
1&0&1&0&1&0&1&0&1&0&1&0&$s_0$&1\\
\hline
0&1&1&0&0&1&1&0&0&1&1&0&$s_1$&1\\
\hline
0&0&0&1&1&1&1&0&0&0&0&1&$s_2$&0\\
\hline
0&0&0&0&0&0&0&1&1&1&1&1&$s_3$&1\\
\hline
\end{tabular}
\end{center}
\end{table}\\
\\
Мы видим, что 1 и 2 контрольные биты у нас получились иные. 1 + 2 = 3 -- бит неверный, инвертируем его.\\
\\
\section{Хэширование}

\textbf{Хеш-функция}  -- функция, осуществляющая преобразование массива входных данных произвольной длины в (выходную) битовую строку установленной длины, выполняемое определённым алгоритмом. Преобразование, производимое хеш-функцией, называется хешированием. Исходные данные называются входным массивом, "ключом" или "сообщением". Результат преобразования (выходные данные) называется "хешем", "хеш-кодом", "хеш-суммой", "сводкой сообщения".\\

Хеш-функции применяются в следующих случаях:\\

1)при построении ассоциативных массивов;\\

2)при поиске дубликатов в сериях наборов данных;\\

3)при построении уникальных идентификаторов для наборов данных;\\

4)при вычислении контрольных сумм от данных (сигнала) для последующего обнаружения в них ошибок (возникших случайно или внесённых намеренно), возникающих при хранении и/или передаче данных;\\

5)при сохранении паролей в системах защиты в виде хеш-кода (для восстановления пароля по хеш-коду требуется функция, являющаяся обратной по отношению к использованной хеш-функции);\\

6)при выработке электронной подписи (на практике часто подписывается не само сообщение, а его «хеш-образ»);\\

и др.\\

В общем случае (согласно принципу Дирихле) нет однозначного соответствия между хеш-кодом (выходными данными) и исходными (входными) данными. Возвращаемые хеш-функцией значения (выходные данные) менее разнообразны, чем значения входного массива (входные данные). Случай, при котором хеш-функция преобразует более чем один массив входных данных в одинаковые сводки, называется «коллизией» => вероятность возникновения коллизий используется для оценки качества хеш-функций.\\

\textbf{Хорошая хэш-функция} должна удовлетворять двум свойствам:\\
1)быстрое вычисление\\
2)минимальное количество коллизий\\

\textbf{Пример (хэш-код как остаток от деления на число всех возможных хэшей):}\\

Хеш-функция может вычислять «хеш» как остаток от деления входных данных на M:\\
$ h(k)=k(mod$ $M)$,\\
где M — количество всех возможных «хешей» (выходных данных).При этом очевидно, что при чётном M значение функции будет чётным при чётном k и нечётным — при нечётном k. Также не следует использовать в качестве M степень основания системы счисления компьютера, так как «хеш-код» будет зависеть только от нескольких цифр числа k, расположенных справа, что приведёт к большому количеству коллизий. На практике обычно выбирают простое M; в большинстве случаев этот выбор вполне удовлетворителен.\\

\noindent\textbf{Идеальное хэширование:}\\
Идеальной хеш-функцией  называется такая функция, которая отображает каждый ключ из набора S во множество целых чисел без коллизий. В математике такое преобразование называется инъективным отображением. Идеальное хеширование применяется, если требуется присвоить уникальный идентификатор ключу без сохранения какой-либо информации о ключе. \\

\noindent\textbf{Универсальное хэширование:}\\
Универсальным хешированием называется хеширование, при котором используется не одна конкретная хеш-функция, а происходит выбор хеш-функции из заданного семейства по случайному алгоритму. Универсальное хеширование обычно отличается низким числом коллизий, применяется, например, при реализации хеш-таблиц и в криптографии. \\
\end{document}