\documentclass[a4paper,12pt]{article}
\usepackage{cmap}
\usepackage {listings}
\usepackage {misccorr}
\usepackage{graphicx}
\setlength{\parindent}{5ex}	
\usepackage{amssymb}
\usepackage{cmap}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\author{Зарина}
\title{Задачи о "Рюкзаке"}
\date{6 ноября 2019}
\begin{document}
\section {Задача о "рюкзаке"}

Непрерывная задача о рюкзаке рассматривает неделимые объекты (стоимость пропорциональна массе) и представляет собой NP-полную задачу комбинаторной оптимизации. Своё название получила от конечной цели: уложить как можно большее число ценных вещей в рюкзак при условии, что вместимость рюкзака ограничена.

Задачу о рюкзаке можно решить несколькими способами:\\
1) Перебирать все подмножества набора из N предметов. Сложность: $O(2N)$.\\
2) Методом Meet-in-the-middle. Сложность: $O(2N/2N)$\\
3) Метод динамического программирования. Сложность: $O(NW).\\

\section{Жадный алгоритм}
1) Выберем сначала максимально удовлетворяющую стоимость\\
2) Возьмем этот предмет столько, сколько сможем\\
=> Существует класс жадных алгоритмов, не решающих задачу оптимально, но приводящих к оптимальному решению - \textbf{градиентный метод}.\\
Например, поиск глобального минимума через локальные минимумы.
\section {Градиентный метод} \\ 
Рассмотрим несколько примеров:\\

\textbf{1)Метод бисекции.}\\
-простейший численный метод для решения нелинейных уравнений вида f(x)=0. Предполагается только непрерывность функции f(x). Поиск основывается на теореме о промежуточных значениях:
Для A<0, B>0 на отрезке [A;B] существует точка, пересекающая ось абсцисс.\\

\textbf{2)Метод Ньютона.}\\
-если $x_{n}$ — некоторое приближение к корню  уравнения f(x)=0, то следующее приближение определяется как корень касательной к функции f(x), проведенной в точке $x_{n}$ .\\

\textbf{3)} Значение градиента в точке - вектор, направление которого задает значение производной в точке f(x,y,z).
С помощью этого метода обучается нейронная сеть.\\
\section{Динамическое программирование}
-довольно близко к жадному алгоритму\\
Пусть $A(k,s)$ есть максимальная стоимость предметов, которые можно уложить в рюкзак вместимости s, если можно использовать только первые k предметов, то есть ${n1,n2,…,nk}$$, назовем этот набор допустимых предметов для $A(k,s)$.

$A(k,0)=0$

$A(0,s)=0$

Найдем $A(k,s)$. Возможны 2 варианта:

1) Если предмет k не попал в рюкзак. Тогда $A(k,s)$ равно максимальной стоимости рюкзака с такой же вместимостью и набором допустимых предметов ${n1,n2,…,nk−1}$, то есть $A(k,s)=A(k−1,s)$\\
2) Если k попал в рюкзак. Тогда $A(k,s)$ равно максимальной стоимости рюкзака, где вес s уменьшаем на вес k-ого предмета и набор допустимых предметов ${n1,n2,…,nk−1}$ плюс стоимость k, то есть $A(k−1,s−wk)+pk$
То есть: $A(k,s)=max(A(k−1,s), \:A(k−1,s−wk)+pk)$

Стоимость искомого набора равна $A(N,W)$, так как нужно найти максимальную стоимость рюкзака, где все предметы допустимы и вместимость рюкзака W.
Заметим, что при построении A мы выбирали максимум из этих значений и записывали в $A(i,w)$. Тогда будем сравнивать $A(i,w)$ c $A(i−1,w)$, если равны, тогда ni не входит в искомый набор, иначе входит.

Метод динамического программирование всё равно не позволяет решать задачу за полиномиальное время, потому что задача о ранце (или задача о рюкзаке) — одна из NP-полных задач комбинаторной оптимизации.

Пример:\\
\textbf{Числа Фибоначчи}\\
Можно воспользоваться формулой Бине.\\
Пусть есть массив $a[n+1] ={-1,-1,-1...-1}$

\lstset {language = C++, frame = single}
\begin{lstlisting}
if (a[n]==-1)
a[n]=f(n-1)+f(n-2);
return a[n]
\end{lstlisting}

Мы не делали лишних вычислений, а заполняли промежуточные результаты и пользуемся ими:\\
1) Сформулировали задачу в рекуррентной форме\\
2) Последовательно заполнили массив обратным ходом\\


\end{document}
